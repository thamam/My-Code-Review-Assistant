import { GoogleGenAI } from "@google/genai";
import { PRData, Diagram } from '../types';

export class DiagramAgent {
  private ai: GoogleGenAI;

  constructor() {
    this.ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  }

  /**
   * Generates a set of proposed diagrams based on the PR content.
   */
  async proposeDiagrams(prData: PRData): Promise<Diagram[]> {
    // 1. Prepare Context
    // Truncate file content to avoid token limits, focusing on logic structure
    const fileContext = prData.files
      .filter(f => f.status !== 'deleted' && (f.path.endsWith('.ts') || f.path.endsWith('.tsx') || f.path.endsWith('.py') || f.path.endsWith('.js')))
      .map(f => `File: ${f.path}\nContent:\n${(f.newContent || '').slice(0, 5000)}`)
      .join('\n\n');

    const prompt = `
      You are a specialized Software Architecture Agent. Your task is to analyze the following code changes from a Pull Request and generate Mermaid.js Sequence Diagrams that best explain the logic flow.

      PR Title: ${prData.title}
      PR Description: ${prData.description}

      CODE CONTEXT:
      ${fileContext}

      INSTRUCTIONS:
      1. Analyze the changes to identify the 1-3 most critical control flows, API interactions, or state changes.
      2. For each flow, generate a Mermaid Sequence Diagram.
      3. Return ONLY a JSON array. Do not include markdown code fences.
      
      JSON Schema:
      [
        {
          "title": "Short descriptive title",
          "description": "Explanation of what this diagram shows",
          "mermaidCode": "sequenceDiagram\n..."
        }
      ]

      Rules for Mermaid:
      - Use 'sequenceDiagram' type.
      - Use 'participant' or 'actor' clearly.
      - Keep text labels concise.
      - Use standard Mermaid syntax.
    `;

    try {
      const response = await this.ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt,
        config: {
          responseMimeType: "application/json"
        }
      });

      const text = response.text;
      console.log("[DiagramAgent] Raw AI Response:", text);

      if (!text) throw new Error("No response from AI");

      const rawDiagrams = JSON.parse(text);
      
      return rawDiagrams.map((d: any, idx: number) => ({
        id: `auto-diagram-${Date.now()}-${idx}`,
        title: d.title,
        description: d.description,
        mermaidCode: d.mermaidCode,
        timestamp: Date.now(),
        isAutoGenerated: true
      }));

    } catch (e) {
      console.error("Diagram Generation Failed", e);
      throw e;
    }
  }

  /**
   * Generates a specific diagram based on user prompt
   */
  async generateCustomDiagram(prData: PRData, userPrompt: string): Promise<Diagram> {
    const fileContext = prData.files
        .slice(0, 10) // Limit to top 10 files for performance
        .map(f => `File: ${f.path}\nContent:\n${(f.newContent || '').slice(0, 3000)}`)
        .join('\n\n');

    const prompt = `
      Generate a Mermaid.js Sequence Diagram based on the user's request.

      User Request: "${userPrompt}"

      PR Context:
      ${fileContext}

      Return ONLY a JSON object.
      {
         "title": "Title based on request",
         "description": "Brief description",
         "mermaidCode": "sequenceDiagram\n..."
      }
    `;

    const response = await this.ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt,
        config: { responseMimeType: "application/json" }
    });
    
    console.log("[DiagramAgent] Custom Gen Response:", response.text);

    const data = JSON.parse(response.text!);
    
    return {
        id: `custom-diagram-${Date.now()}`,
        title: data.title,
        description: data.description,
        mermaidCode: data.mermaidCode,
        timestamp: Date.now(),
        isAutoGenerated: false
    };
  }
}