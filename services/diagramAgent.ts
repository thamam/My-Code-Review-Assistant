
import { GoogleGenAI, Type } from "@google/genai";
import { PRData, Diagram, CodeReference } from '../types';
import { resolveFilePath } from '../utils/fileUtils';

export class DiagramAgent {
  private ai: GoogleGenAI;

  constructor() {
    this.ai = new GoogleGenAI({ apiKey: import.meta.env.VITE_GEMINI_API_KEY });
  }

  private parseMermaidReferences(rawCode: string = "", prFiles: string[]): { cleanedCode: string, references: CodeReference[] } {
    const references: CodeReference[] = [];
    if (!rawCode) return { cleanedCode: "", references: [] };

    // Pattern: {description}§{filepath}:{line}
    const refPattern = /([^:\n>]+)§([^:\n]+):(\d+)/g;

    const cleanedCode = rawCode.replace(refPattern, (match, description, filepath, lineStr) => {
      const line = parseInt(lineStr, 10);
      const refId = `ref-${Math.random().toString(36).substr(2, 9)}`;
      const resolution = resolveFilePath(filepath.trim(), prFiles);

      references.push({
        id: refId,
        description: description.trim(),
        filepath: filepath.trim(),
        line: isNaN(line) ? 1 : line,
        resolvedPath: resolution.resolved,
        status: resolution.resolved ? 'valid' : 'unresolved'
      });

      return description.trim();
    });

    return { cleanedCode, references };
  }

  async proposeDiagrams(prData: PRData): Promise<Diagram[]> {
    const prFilePaths = prData.files.map(f => f.path);

    // Provide a complete manifest so the agent knows every file exists
    const manifest = prData.files.map(f => `- ${f.path} (${f.status})`).join('\n');

    // Sample content for core logic files
    const fileContext = prData.files
      .filter(f => f.status !== 'deleted' && (f.path.endsWith('.ts') || f.path.endsWith('.tsx') || f.path.endsWith('.py') || f.path.endsWith('.js')))
      .slice(0, 15) // Ensure we don't exceed token limits but get enough context
      .map(f => `File: ${f.path}\nContent:\n${(f.newContent || '').slice(0, 2000)}`)
      .join('\n\n');

    const prompt = `
      You are Theia, a world-class Software Architect. Analyze this PR and generate 2 high-value Mermaid.js Sequence Diagrams.
      
      PR: ${prData.title}
      Description: ${prData.description}

      ## PROJECT MANIFEST (All changed files)
      ${manifest}

      ## KEY FILE CONTENTS
      ${fileContext}

      ## FORMAT RULES (CRITICAL)
      1. Every message label MUST use this format: {description}§{filepath}:{line}
         Example: "Initialize pipeline§src/main.py:42"
      2. Use valid sequenceDiagram syntax.
      3. Assign specific, descriptive titles. NO "Untitled" or generic names.
      4. Ensure you reference the correct paths from the MANIFEST above.

      ## Output Schema
      Return a JSON array of objects. Each object MUST have:
      - title: Meaningful, specific name.
      - description: One-sentence summary.
      - mermaidCode: Valid sequenceDiagram code using the § format for messages.
    `;

    try {
      const response = await this.ai.models.generateContent({
        model: 'gemini-2.0-flash-exp',
        contents: prompt,
        config: {
          responseMimeType: "application/json",
          responseSchema: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                title: { type: Type.STRING },
                description: { type: Type.STRING },
                mermaidCode: { type: Type.STRING }
              },
              required: ["title", "description", "mermaidCode"]
            }
          }
        }
      });

      const text = response.text;
      if (!text) throw new Error("No response from AI");

      const rawDiagrams = JSON.parse(text);
      if (!Array.isArray(rawDiagrams)) throw new Error("AI returned malformed diagram list");

      return rawDiagrams.map((d: any, idx: number) => {
        const { cleanedCode, references } = this.parseMermaidReferences(d.mermaidCode || "", prFilePaths);
        return {
          id: `auto-diagram-${Date.now()}-${idx}`,
          title: d.title || `Flow Analysis ${idx + 1}`,
          description: d.description || "Architectural flow analysis.",
          mermaidCode: cleanedCode,
          references,
          timestamp: Date.now(),
          isAutoGenerated: true
        };
      });
    } catch (e) {
      console.error("Diagram Generation Failed", e);
      throw e;
    }
  }

  async generateCustomDiagram(prData: PRData, userPrompt: string): Promise<Diagram> {
    const prFilePaths = prData.files.map(f => f.path);
    const manifest = prData.files.map(f => `- ${f.path}`).join('\n');
    const prompt = `Generate a Mermaid sequence diagram for: "${userPrompt}". 
    MANIFEST: ${manifest}
    CRITICAL: Use the format "{description}§{filepath}:{line}" for ALL message labels. 
    Return JSON with keys 'title', 'description', and 'mermaidCode'.`;

    try {
      const response = await this.ai.models.generateContent({
        model: 'gemini-2.0-flash-exp',
        contents: prompt,
        config: { responseMimeType: "application/json" }
      });

      const text = response.text;
      if (!text) throw new Error("No response");

      const data = JSON.parse(text);
      const { cleanedCode, references } = this.parseMermaidReferences(data.mermaidCode || "", prFilePaths);

      return {
        id: `custom-diagram-${Date.now()}`,
        title: data.title || "Custom Flow",
        description: data.description || userPrompt,
        mermaidCode: cleanedCode,
        references,
        timestamp: Date.now(),
        isAutoGenerated: false
      };
    } catch (e) {
      console.error("Custom Diagram Failed", e);
      throw e;
    }
  }
}
